#  Show symlinks in given directory
#   -----------------------------------------------------
function lsym() {
    for link in $(find ${1:-"$(pwd)"} -maxdepth 1 -type l); do
        echo "$link -> $(readlink $link)";
    done;
}

#  Show directories in given directory (including symlink dirs)
#   -----------------------------------------------------
function lsd() {
    ls -p | grep / --color=never;
}

min() {
    ((($1 < $2)) && echo $1) || echo $2
}

# Quick up n levels
# Requires: n >= 0
up() {
    # default to 1
    declare -i d=${@:-1};
    # ensure non-negative
    (($d < 0)) && (>&2 echo "up: Error: negative value provided") && return 1;
    # remove last d directories from pwd, append "/" in case result is empty
    cd "$(pwd | sed -E 's;(/[^/]*){0,'$d'}$;;')/";
}

zman() {
    PAGER="less -g -s '+/^       "$1" '" command man zshall
}

# split string into multiple lines(array). Supports regex
split(){
    awk -F "$1" '{ for (i=1; i<=NF;++i){print $i;} }'
}

# join input lines on pattern
join() {
    sep=''
    while read data; do
        echo -n $sep$data;
        sep=$1;
    done;
    echo;
}

# run commands in the background
background() {
    nohup bash -c "$@" &
}

qaz() {
    echo 'q w e rt | yu i o p'
    echo 'a s d fg | hj k l ;'
    echo 'z x c vb | nm , . /'
}

code_test() {
    range=($(echo {1..7} {30..36} {40..47} {90..97} {100..107} | split ' '))
    echo "Code 0 (color reset): [0m"
    for i in $range; do print "\e[${i}mCode: $i -- [${i}m\e[0m"; done
}

color_test () {
    for code in {000..255}; do
        print -P -- "$code: %F{$code}Test%f %K{$code}Test%k";
    done
}

function ls() {
    command ls --color=auto $@
}

function termcolors () {
    print TERM
    print -P "Foreground: >█<"
    print -P "Background: >%S█%s<\n"
    print "      0 1 2 3 4 5 6 7"
    for b (0 1)
    do
        printf "%d %2d " $b $(( 8 * b ))
        for r (0 1 2 3 4 5 6 7)
        do
            c=$(( 8 * b + r ))
            print -nP "%K{$c}  %k"
        done
        printf " %2d\n" $(( 8 * b + 7 ))
    done

    print

    print RGB
    for r (0 1 2 3 4 5)
    do
        print "$r $(( 16 + 36 * r )) - $(( 16 + 36 * r + 35 ))\n       0 1 2 3 4 5"
        for g (0 1 2 3 4 5)
        do
            printf "%d %3d " $g $(( 16 + 36 * r + 6 * g ))
            for b (0 1 2 3 4 5)
            do
                c=$(( 16 + 36 * r + 6 * g + b ))
                print -nP "%K{$c}  %k"
            done
            printf " %3d\n" $(( 16 + 36 * r + 6 * g + 5))
        done
        print
    done

    print

    print GRAY
    for g in $(seq 0 23)
    do
        c=$(( 232 + g ))
        printf "%2d %3d " $g $c
        print -P "%K{$c}  %k"
    done
}


map_hops(){
    iponmap -t $(sudo mtr -r -b -l $1  2> /dev/null |\
        grep '^h' |\
        sed 's/.* //g' |\
        join ' '
    );
}

# Get number of visible characters in a string
num_visible(){
    t=$(echo "$1" | perl -pe 's/\x1b\[[^m]+m//g')
    echo ${#t}
}

# fairly slow
get_cursor_row() {
    exec < /dev/tty;
    oldstty=$(stty -g);
    stty raw -echo min 0;
    echo -en "\033[6n" > /dev/tty;
    IFS=';' read -r -d R -A pos;
    stty $oldstty;
    echo ${pos[1]:2}
}

gen_MAC() {
    s=""; repeat 6; do echo -n "$s"; printf "%02X" "$(( $RANDOM % 256 ))"; s=":"; done;
    echo
}

randomize_MAC() {
    set_MAC "$(gen_MAC)";
}

set_MAC() {
    sudo ifconfig en0 ether "$1";
    sudo ifconfig en0 down;
    sudo ifconfig en0 up;
}


find_owners() {
    local cwd=`pwd`
    while true; do
        ls 'OWNERS' &> /dev/null && pwd && cat OWNERS
        if [[ `pwd` == '/' ]]; then
            cd $cwd
            return;
        fi;
        cd ..
    done
}

git_root() {
    git rev-parse --show-toplevel
}

# fbr - checkout git branch
fbr() {
  local branches branch
  branches=$(git branch -vv) &&
  branch=$(echo "$branches" | fzf +m) &&
  git checkout $(echo "$branch" | awk '{print $1}' | sed "s/.* //")
}

# fbr - checkout git branch (including remote branches)
fbrr() {
  local branches branch
  branches=$(git branch --all | grep -v HEAD) &&
  branch=$(echo "$branches" |
           fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
  git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

# fcoc - checkout git commit
fcoc() {
  local commits commit
  commits=$(git log --pretty=oneline --abbrev-commit --reverse) &&
  commit=$(echo "$commits" | fzf --tac +s +m -e) &&
  git checkout $(echo "$commit" | sed "s/ .*//")
}

cros_sdk() {
    cd ${HOME}/chromiumos;
    command cros_sdk $@
}

let_it_snow() {
    type lolcat &> /dev/null || sudo apt-get install lolcat
    ruby -e 'C=`stty size`.scan(/\d+/)[1].to_i;S=["2743".to_i(16)].pack("U*");a={};puts "\033[2J";loop{a[rand(C)]=0;a.each{|x,o|;a[x]+=1;print "\033[#{o};#{x}H \033[#{a[x]};#{x}H#{S} \033[0;0H"};$stdout.flush;sleep 0.1}' 2&> /dev/null | lolcat
}


unalias z 2> /dev/null;
z() {
    j $@
}

j() {
    if [[ "$#" -ne 0 ]]; then
        cd "$(autojump $@)"
        return
    fi
    local dir="$(autojump -s |
        sed '/_____/Q; s,'${HOME}',~,' |
        sort -n -k1,1 -r |
        fzf --height 40% --reverse --inline-info |
        sed 's/^[0-9,.:]*\s*//')"
    cd "$(eval echo $dir)"
}

git_super_duper_status() {
    [[ "$GIT_BRANCH" != ":" ]] && print $@ "$(git_super_status)"
}

vcs_info() {
    git_super_duper_status $@
}

function cd() {
    if [[ "$#" != 0 ]]; then
        builtin cd "$@";
        return
    fi
    while true; do
        local lsd=($(echo ".." && ls -p | grep '/$' | sed 's;/$;;'))
        local dir="$(printf '%s\n' "${lsd[@]}" |
            fzf --reverse --preview '
                __cd_nxt="$(echo {})";
                __cd_path="$(echo $(pwd)/${__cd_nxt} | sed "s;//;/;")";
                echo $__cd_path;
                echo;
                ls -p --color=always "${__cd_path}";
        ')"
        [[ ${#dir} != 0 ]] || return 0
        builtin cd "$dir" &> /dev/null
    done
}

function nav() {
    type highlight &> /dev/null || sudo apt-get install highlight
    while true; do
        local lsd=($(echo ".." && ls -p))
        local sel="$(printf '%s\n' ${lsd[@]} |
            fzf --reverse --preview '
                __nav_nxt="$(echo {})";
                __nav_path="$(echo $(pwd)/${__nav_nxt} | sed "s;//;/;")";
                if [ -d "$__nav_nxt" ]; then
                    echo $__nav_path;
                    echo;
                    ls -p --color=always "${__nav_path}";
                else
                    echo $__nav_path;
                    highlight "$__nav_nxt" --out-format xterm256 --line-numbers --force --style=solarized-dark
                fi
        ')"
        [[ ${#sel} != 0 ]] || return 0
        if [ -d "$sel" ]; then
            builtin cd "$sel" &> /dev/null
        else
            ${EDITOR:-vim} "$sel"
        fi
    done
}

export BOOKMARKS=~/bookmarks
abm() {
    touch "$BOOKMARKS"
    pwd >> "$BOOKMARKS"
    sort -u -o "$BOOKMARKS" "$BOOKMARKS"
}

dbm() {
    touch "$BOOKMARKS"
    cat "$BOOKMARKS" | grep -v "^$(pwd)$" > "$BOOKMARKS"
}

bm() {
    touch "$BOOKMARKS"
    cd "$(cat "$BOOKMARKS" | fzf --height 40% --reverse --inline-info)"
}

powerline_font_test() {
    echo -e "Powerline glyphs:\n\
        Code points Glyphe  Description                Old code point
        U+E0A0      \xee\x82\xa0       Version control branch     (U+2B60 \xe2\xad\xa0 )\n\
        U+E0A1      \xee\x82\xa1       LN (line) symbol           (U+2B61 \xe2\xad\xa1 )\n\
        U+E0A2      \xee\x82\xa2       Closed padlock             (U+2B64 \xe2\xad\xa4 )\n\
        U+E0B0      \xee\x82\xb0       Rightwards black arrowhead (U+2B80 \xe2\xae\x80 )\n\
        U+E0B1      \xee\x82\xb1       Rightwards arrowhead       (U+2B81 \xe2\xae\x81 )\n\
        U+E0B2      \xee\x82\xb2       Leftwards black arrowhead  (U+2B82 \xe2\xae\x82 )\n\
        U+E0B3      \xee\x82\xb3       Leftwards arrowhead        (U+2B83 \xe2\xae\x83 )\n\
        "
}

#   Make tmux auto reattach if it can
#   -----------------------------------------------------
t() {
    local session_name="${@:-0}"
    tmx2 a -t $session_name > /dev/null || tmx2 new -s $session_name
}

batt() {
    highlight $@ --out-format xterm256 --line-numbers --force --style=solarized-dark
}

p() {
    if ! ps -p $SSH_AGENT_PID > /dev/null; then
        echo "Refreshing ssh agent"
        eval "$(ssh-agent -s)"
    fi
    prodaccess
}

# fup - cd to selected parent directory
fup() {
  local declare dirs=()
  get_parent_dirs() {
    if [[ -d "${1}" ]]; then dirs+=("$1"); else return; fi
    if [[ "${1}" == '/' ]]; then
      for _dir in "${dirs[@]}"; do echo $_dir; done
    else
      get_parent_dirs $(dirname "$1")
    fi
  }
  local DIR=$(get_parent_dirs $(realpath "${1:-$(dirname $PWD)}") | fzf --height 20% )
  cd "$DIR"
}

bb() {
    blaze build $(blaze query :all | fzf)
}

summation() {
    awk '{s+=$1} END {print s}'
}

# search source code, then pipe files with 10 line buffer into fzf preview using bat.
# requirements:
# - fzf: https://github.com/junegunn/fzf
# - ag: https://github.com/ggreer/the_silver_searcher
# - bat: https://github.com/sharkdp/bat
# - vim-fetch: https://github.com/wsdjeg/vim-fetch
# Notes:
#  - if you want to replace ag for rg feel free (https://blog.burntsushi.net/ripgrep/)
#  - Same goes for bat, although ccat and others are definitely worse
#  - the $ext extraction uses a ZSH specific text globber
s(){
  local margin=5 # number of lines above and below search result.
  local preview_cmd='search={};file=$(echo $search | cut -d':' -f 1 );'
  preview_cmd+="margin=$margin;" # Inject value into scope.
  preview_cmd+='line=$(echo $search | cut -d':' -f 2 ); ext=$(echo $file(:e));'
  preview_cmd+='tail -n +$(( $(( $line - $margin )) > 0 ? $(($line-$margin)) : 0)) $file | head -n $(($margin*2+1)) |'
  preview_cmd+='bat --paging=never --color=always --style=plain --language=$ext --highlight-line $(($margin+1))'
  full=$(ag "$*" \
    | fzf --select-1 --exit-0 --preview-window up:$(($margin*2+1)) --height=60%  --preview $preview_cmd)
  file="$(echo $full | awk -F: '{print $1}')"
  line="$(echo $full | awk -F: '{print $2}')"
  [ -n "$file" ] && vim "$file" +$line
}

ru() {
    yes | repo upload . --cbr $@ && echo
}
